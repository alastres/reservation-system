datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}


model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String? // Added for Credentials Auth

  accounts Account[]
  sessions Session[]

  // App specific
  username String? @unique
  timeZone String  @default("UTC")
  language String  @default("es") // "es" or "en"
  maxConcurrentClients Int @default(1)

  // Profile
  bio           String?
  coverImage    String?
  address       String?
  phone         String?
  profilePicUrl String?

  // Platform Subscription (for owners to use the platform)
  subscriptionStatus    SubscriptionStatus @default(INACTIVE)
  subscriptionPlan      SubscriptionPlan?
  stripeCustomerId      String?            @unique
  stripeSubscriptionId  String?            @unique
  subscriptionEndsAt    DateTime?

  // Organization (Business Plan)
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)
  orgRole        OrganizationRole? @default(MEMBER)

  // Stripe Connect (for owners receiving payments)
  stripeConnectAccountId String?           @unique
  stripeConnectStatus    String?           @default("INACTIVE")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  services           Service[]
  bookings           Booking[]           @relation("UserBookings")
  availabilityRules  AvailabilityRule[]
  availabilityExceptions AvailabilityException[]
  notificationPreferences Json?
  notificationLogs        NotificationLog[]

  role      Role        @default(OWNER)
  SystemLog SystemLog[]
}

model Organization {
  id      String   @id @default(cuid())
  name    String
  slug    String?  @unique
  
  // Subscription is held by the organization leader (User) usually, 
  // but we can track organization-wide usage/status here if needed.
  // For now, simpler to link Org to the functionality.

  members User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}


enum OrganizationRole {
  OWNER
  ADMIN
  MEMBER
}

enum Role {
  ADMIN
  OWNER
  CLIENT
}


// ... (Other models)

model Service {
  id          String  @id @default(cuid())
  title       String
  description String?
  duration    Int // in minutes
  price       Float   @default(0)
  location    String? // e.g. "Zoom", "Google Meet"
  url         String // slug for public url

  // Customization
  color      String @default("#6366f1") // Violet-500 default
  capacity   Int    @default(1) // 1 for 1-on-1, >1 for groups
  bufferTime Int    @default(0) // Minutes after appointment
  minNotice  Int    @default(60) // Minutes before booking allowed

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Optional: Link service to organization
  organizationId String?

  bookings Booking[]

  // Custom Form Fields
  customInputs        Json? // [{ label: "Phone", type: "text", required: true }]
  isRecurrenceEnabled Boolean @default(false)
  maxRecurrenceCount  Int?    @default(4)

  // Location Logic
  locationType LocationType @default(GOOGLE_MEET)
  locationUrl  String? // For static links vs dynamic
  address      String? // For IN_PERSON

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Payment
  requiresPayment Boolean @default(false)

  // Concurrency (Service specific capacity)
  isConcurrencyEnabled Boolean @default(false)
  maxConcurrency       Int     @default(1)

  @@unique([userId, url])
}


enum LocationType {
  GOOGLE_MEET
  ZOOM
  PHONE
  IN_PERSON
  CUSTOM
}

model Booking {
  id        String   @id @default(cuid())
  startTime DateTime
  endTime   DateTime

  serviceId String
  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  clientName     String
  clientEmail    String
  clientPhone    String? // Copied from form if LocationType == PHONE
  clientTimeZone String? // Stores the client's browser timezone
  notes          String?
  answers        Json? // { "Phone": "123-456" }
  recurrenceId   String? // ID grouping recurring bookings

  // Integration
  googleEventId String?
  joinUrl       String? // Google Meet / Zoom link

  status BookingStatus @default(CONFIRMED)

  // If the booker is a registered user
  userId String?
  user   User?   @relation("UserBookings", fields: [userId], references: [id], onDelete: SetNull)

  // Payment
  paymentStatus   PaymentStatus @default(PENDING)
  paymentIntentId String?       @unique
  amountPaid      Float?
  currency        String        @default("usd")
  refundId        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([serviceId, startTime, status])
  @@index([userId, startTime])
}

enum BookingStatus {
  CONFIRMED
  CANCELLED
  PENDING
}

enum PaymentStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
  REFUNDED
}

enum SubscriptionStatus {
  ACTIVE
  INACTIVE
  CANCELLED
  PAST_DUE
  TRIALING
}


enum SubscriptionPlan {
  FREE
  PRO
  BUSINESS
}


model AvailabilityRule {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  dayOfWeek Int // 0 = Sunday, 1 = Monday...
  startTime String // "09:00"
  endTime   String // "17:00"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AvailabilityException {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  date DateTime @db.Date // Specific date

  isAvailable Boolean @default(true) // If true, use start/endTime to OVERRIDE. If false, blocked.
  startTime   String?
  endTime     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, date])
}

model NotificationLog {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type     String // "BOOKING_CONFIRMATION", "REMINDER_24H", etc
  status   String // "SENT", "FAILED"
  metadata Json? // Any extra info

  createdAt DateTime @default(now())
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?  @db.Text
  access_token       String?  @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?  @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model SystemLog {
  id        String   @id @default(cuid())
  action    String
  details   String?
  ipAddress String?
  
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
}
